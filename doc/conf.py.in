#!/usr/bin/env python3
#
# Configuration file for the Sphinx documentation builder
#   Docs:   http://www.sphinx-doc.org/en/master/config
#
# NOTE This needs to be run through CMake to have variables replaced


import os
import sys

import sphinx

# -- Path setup ---------------------------------------------------------------

# The source directory of the docs, set by CMake
# doc_dir = os.path.dirname(__file__)
doc_dir = "@CMAKE_CURRENT_SOURCE_DIR@"


# -- Project information ------------------------------------------------------

project = "Utopia"
copyright = "2016 – 2024, Utopia Developers"
author = "Utopia Developers"

# The short X.Y version
version = "@CMAKE_PROJECT_VERSION@"

# The full version, including alpha/beta/rc tags
release = "@CMAKE_PROJECT_VERSION@"

# -- General configuration ----------------------------------------------------

# If your documentation needs a minimal Sphinx version, state it here.
needs_sphinx = "5.3"

# Add any Sphinx extension module names here, as strings. They can be
# extensions coming with Sphinx (named "sphinx.ext.*") or your custom ones.
extensions = [
    "sphinx.ext.autodoc",
    "sphinx.ext.autodoc.typehints",
    "sphinx.ext.doctest",
    "sphinx.ext.intersphinx",
    "sphinx.ext.todo",
    "sphinx.ext.coverage",
    "sphinx.ext.mathjax",
    "sphinx.ext.ifconfig",
    "sphinx.ext.viewcode",
    "sphinxarg.ext",
    #
    # --- Additional extensions ---
    "sphinx_togglebutton",
    #   ... to include doxygen docs
    "breathe",
    #
    #   ... to render markdown files and tables
    "myst_parser",
    "sphinx_markdown_tables",
    #
    #   ... to pre-process Google-style Python docstrings
    "sphinx.ext.napoleon",
    #
    #   ... to have the IPython directive available for code examples
    "IPython.sphinxext.ipython_console_highlighting",
    "IPython.sphinxext.ipython_directive",
]

# Add any paths that contain templates here, relative to this directory.
templates_path = ["_templates"]

# The suffix(es) of source filenames.
# You can specify multiple suffix as a dict mapping to file types:
source_suffix = {
    ".rst": "restructuredtext",
    ".md": "markdown",
    ".cff": "markdown",
}

# The master toctree document.
master_doc = "index"

# The language for content autogenerated by Sphinx. Refer to documentation
# for a list of supported languages.
#
# This is also used if you do content translation via gettext catalogs.
# Usually you set "language" from the command line for these cases.
language = "en"

# List of patterns, relative to source directory, that match files and
# directories to ignore when looking for source files.
# This pattern also affects html_static_path and html_extra_path.
exclude_patterns = [
    "_build",
    "Thumbs.db",
    ".DS_Store",
    "_inc/utopya/**",
]
# NOTE The _inc/utopya directory is used as a workaround to have all the tested
#      examples available for literalincludes. Once the utopya documentation is
#      ready, this would no longer be required.

# The name of the Pygments (syntax highlighting) style to use.
pygments_style = None

# Can suppress some warnings that cannot be resolved
suppress_warnings = [
    "myst.xref_missing",  # because of different syntax in copied .md files
]


# -- Options for HTML output --------------------------------------------------

# The theme to use for HTML and HTML Help pages.  See the documentation for
# a list of builtin themes.
#
html_theme = "sphinx_book_theme"

# Theme options are theme-specific and customize the look and feel of a theme
# further.  For a list of options available for each theme, see the theme's
# documentation.
#   https://sphinx-book-theme.readthedocs.io/en/latest/configure.html
#
html_theme_options = {
    "repository_url": "https://gitlab.com/utopia-project/utopia",
    "use_repository_button": True,
    "use_issues_button": False,     # NOTE Not working with GitLab repos yet
    "use_edit_page_button": False,  # NOTE Not working with GitLab repos yet
    "use_download_button": True,
    "use_fullscreen_button": False,
}

# Add any paths that contain custom static files (such as style sheets) here,
# relative to this directory. They are copied after the builtin static files,
# so a file named "default.css" will overwrite the builtin "default.css".
html_static_path = [f"{doc_dir}/_static"]

# Custom sidebar templates, must be a dictionary that maps document names
# to template names.
#
# The default sidebars (for documents that don't match any pattern) are
# defined by theme itself.  Builtin themes are using these templates by
# default: ``["localtoc.html", "relations.html", "sourcelink.html",
# "searchbox.html"]``.
#
# html_sidebars = {}

# Custom CSS files, assumed one of `html_static_path`
html_css_files = [
    "css/custom.css",
]

# Title and logo, will appear in the top left-hand corner (theme-dependent)
html_title = ""  # ... because there already is a logo
html_logo = f"{doc_dir}/_static/images/logo_blue_full.svg"
html_favicon = f"{doc_dir}/_static/images/favicon_blue.png"

# -- Options for HTMLHelp output ----------------------------------------------

# Output file base name for HTML help builder.
htmlhelp_basename = "utopia-doc"


# -- Options for LaTeX output -------------------------------------------------

latex_elements = {
    # The paper size ("letterpaper" or "a4paper").
    #
    # "papersize": "letterpaper",

    # The font size ("10pt", "11pt" or "12pt").
    #
    # "pointsize": "10pt",

    # Additional stuff for the LaTeX preamble.
    #
    # "preamble": ",

    # Latex figure (float) alignment
    #
    # "figure_align": "htbp",
}

# Grouping the document tree into LaTeX files. List of tuples
# (source start file, target name, title,
#  author, documentclass [howto, manual, or own class]).
latex_documents = [
    (
        master_doc,
        "Utopia.tex",
        "Utopia Documentation",
        "Utopia Developers",
        "manual",
    ),
]


# -- Options for manual page output -------------------------------------------

# One entry per manual page. List of tuples
# (source start file, name, description, authors, manual section).
man_pages = [
    (
        master_doc,
        "utopia",
        "Utopia Documentation",
        [author],
        1,
    ),
]


# -- Options for Texinfo output -----------------------------------------------

# Grouping the document tree into Texinfo files. List of tuples
# (source start file, target name, title, author,
#  dir menu entry, description, category)
texinfo_documents = [
    (
        master_doc,
        "Utopia",
        "Utopia Documentation",
        author,
        "Utopia",
        "A comprehensive modelling framework for complex and evolving systems",
        "Miscellaneous",
    ),
]


# -- Options for Epub output --------------------------------------------------

# Bibliographic Dublin Core info.
epub_title = project

# The unique identifier of the text. This can be a ISBN number
# or the project homepage.
#
# epub_identifier = "

# A unique identification for the text.
#
# epub_uid = "

# A list of files that should not be packed into the epub file.
epub_exclude_files = ["search.html"]



# -----------------------------------------------------------------------------
# -- Extensions ---------------------------------------------------------------
# -----------------------------------------------------------------------------
# -- API reference generation -------------------------------------------------

# If extensions (or modules to document with autodoc) are in another directory,
# add these directories to sys.path here. If the directory is relative to the
# documentation root, use os.path.abspath to make it absolute, like shown here.
# sys.path.insert(
#     0, os.path.abspath(f"{doc_dir}/../python/utopya")  # TODO submodule?
# )


# -- MyST ---------------------------------------------------------------------

# Generate heading anchors, which we need for cross-referencing
myst_heading_anchors = 5


# -- Todo extension -----------------------------------------------------------

# If true, `todo` and `todoList` produce output, else they produce nothing.
todo_include_todos = True

# -- Mathjax configuration ----------------------------------------------------
# see http://www.sphinx-doc.org/en/master/usage/extensions/math.html#module-sphinx.ext.mathjax

mathjax_path = "https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"


# -- Autodoc configuration ----------------------------------------------------
# Show both class docstring and __init__ docstring
autoclass_content = "both"

# Default options
autodoc_default_options = {
    "member-order": "bysource",
    "members": True,
    "special-members": True,
    "show-inheritance": False,
    "undoc-members": False,
    "private-members": False,
    "inherited-members": False,  # WARNING `True` will lead to many warnings!
}
# FIXME These don't seem to be recognized by sphinx-apidoc when creating the
#       utopya API reference ...


# -- Breathe configuration ----------------------------------------------------

breathe_projects = {
    "utopia": "@CMAKE_CURRENT_BINARY_DIR@/doxygen/xml/"
}
breathe_default_project = "utopia"


# -- Napoleon configuration ---------------------------------------------------

napoleon_google_docstring = True
# Whether to parse Google style docstrings. (default: true)

napoleon_numpy_docstring = False
# Whether to parse numpy style docstrings. (default: true)

napoleon_include_init_with_doc = True
# True to list __init___ docstrings separately from the class docstring.
# False to fall back to Sphinx’s default behavior, which considers the
# __init___ docstring as part of the class documentation. Defaults to False.

napoleon_include_private_with_doc = False
# True to include private members (like _membername) with docstrings in the
# documentation. False for Sphinx’s default behavior. Default: False

napoleon_include_special_with_doc = True
# True to include special members (like __membername__) with docstrings in the
# documentation. False to fall back to Sphinx’s default behavior. Default: True



# -- IPython Configuration ----------------------------------------------------
# See https://ipython.readthedocs.io/en/stable/sphinxext.html

ipython_savefig_dir = os.path.join(html_static_path[0], "_ipy")



# -- Intersphinx --------------------------------------------------------------

# Mappings can be looked up from the following GitHub gist:
#   https://gist.github.com/bskinn/0e164963428d4b51017cebdb6cda5209
#
# Further documentation:
#   https://docs.readthedocs.io/en/stable/guides/intersphinx.html
#   https://www.sphinx-doc.org/en/master/usage/extensions/intersphinx.html
#
# In case reference targeting fails, consider using the sphobjinv package
#   https://github.com/bskinn/sphobjinv

# fmt: off
intersphinx_mapping = {
    #
    # First-party docs:
    "paramspace":   ("https://paramspace.readthedocs.io/en/latest/", None),
    "dantro":       ("https://dantro.readthedocs.io/en/latest/", None),
    "utopya":       ("https://utopya.readthedocs.io/en/latest/", None),
    #
    # Third-party docs
    "python":       ("https://docs.python.org/3/", None),
    "sphinx":       ("https://www.sphinx-doc.org/en/master/", None),
    "h5py":         ("https://docs.h5py.org/en/latest/", None),
    "matplotlib":   ("https://matplotlib.org/stable/", None),
    "seaborn":      ("https://seaborn.pydata.org", None),
    "numpy":        ("https://numpy.org/doc/stable/", None),
    "pandas":       ("https://pandas.pydata.org/docs/", None),
    "scipy":        ("https://docs.scipy.org/doc/scipy/", None),
    "xarray":       ("https://docs.xarray.dev/en/stable/", None),
    "dask":         ("https://docs.dask.org/en/stable/", None),
    "networkx":     ("https://networkx.org/documentation/stable/", None),
    "sympy":        ("https://docs.sympy.org/latest/", None),
    "dill":         ("https://dill.readthedocs.io/en/latest/", None),
    "pytest":       ("https://pytest.org/en/stable/", None),
    #
    # Broken:
    # "pydantic":     ("https://pydantic-docs.helpmanual.io/", None),
    # "ruamel.yaml":  ("https://yaml.readthedocs.io/en/latest/", None),
}
# fmt: on


# -- Nitpicky Configuration ---------------------------------------------------
# Be nitpicky about warnings, to show all references where the target could
# not be found
nitpicky = True
nitpick_ignore = []
nitpick_ignore_regex = []

# ... however, we need to exclude quite a lot, so we load the to-be-ignored
# references from a file. This is a list of (type, target) tuples, both entries
# being strings, e.g. `('py:func', 'int')`.
#
# The individual entries can also be regex patterns. To add an entry to the
# regex list instead of the non-regex list, prefix a line with "re: ", e.g.:
#
#       re: py:func ^int$
#
# See the following page for more information and syntax:
#  www.sphinx-doc.org/en/master/usage/configuration.html#confval-nitpick_ignore

for line in open(f"{doc_dir}/.nitpick-ignore"):
    line = line.strip()
    if not line or line.startswith("#"):
        continue

    if line.startswith("re: "):
        _, reftype, target = line.split(" ", 2)
        nitpick_ignore_regex.append((reftype, target.strip()))

    else:
        reftype, target = line.split(" ", 1)
        nitpick_ignore.append((reftype, target.strip()))


# -----------------------------------------------------------------------------
# -- Link-checking ------------------------------------------------------------
# -----------------------------------------------------------------------------
# Docs:
#   https://www.sphinx-doc.org/en/master/usage/configuration.html#options-for-the-linkcheck-builder

linkcheck_retries = 2

# Link patterns to ignore
linkcheck_ignore = [
    # With linkcheck failing to check relative links to the doxygen output,
    # all those need to be ignored.
    r"(\.\./)*doxygen/.*",
    #
    # Same for links to copied files.
    r".*README\.html.*",
    r".*CONTRIBUTING\.html.*",
    r".*CODE_OF_CONDUCT\.html.*",
    r".*COPYING\.html.*",
    #
    # And the IUP homepage, which has some weird certificate settings
    r".*(www\.)?iup\.uni-heidelberg\.de/.*",
    #
    # Sites that do not allow the sphinx linkcheck user agent, or forward to
    # such sites (typically shows a 403 client error) ... even if a custom
    # user agent is set, these sites are not happy.
    r".*(www\.)?intel\.com/.*",
    r".*doi\.org/10\.1103/[Pp]hys[Rr]ev[Ll]ett.*",
]






# #############################################################################
# -----------------------------------------------------------------------------
# -- Custom build setup -------------------------------------------------------
# -----------------------------------------------------------------------------


def on_missing_reference(app, env, node, contnode):
    """Custom handler for missing sphinx references

    This makes it possible to ignore certain classes of warnings completely,
    mainly those that can't be fixed here for the Utopia docs. That way, the
    remaining warnings retain some meaning ...

    Based on: https://stackoverflow.com/a/38576424/1827608
    """
    if (
        node["reftype"] in ("any", "myst") or
        node["refdomain"] in ("cpp", "std") or
        node["reftarget"].startswith("dantro") or
        node["reftarget"].startswith("xarray") or
        node["reftarget"].startswith("xr") or
        node["reftarget"].startswith("numpy") or
        node["reftarget"].startswith("np") or
        node["reftarget"].startswith("collections")
    ):
        # Ignore this missing reference warning (denoted by NOT returning None)
        return contnode
    return None


def manipulate_source_read(app, docname: str, source: list):
    """Manipulates individual files according to some rules.

    WHY? Because this seems to be the only way to address the following
    warnings:

        - Manipulate/delete wrong relative paths in copied files (readme, …)
          or make other changes to copied files.
        - Classes inherited from matplotlib which get a docstring that does not
          follow the usual docstring formats, thus creating a warning. That
          docstring cannot be removed or overwritten due to matplotlib's
          efforts of force-inheriting docstring information ...

    Better idea how to do it? Feel free to try it out and (if it works), let
    us know -- we would very much appreciate it!

    .. note::

        ``source`` contains a *single* entry that is the full page source as a
        string, including all line break characters. Manipulation of the
        source can be done by *mutably* changing that single entry in the
        ``source`` object (a list).
    """
    if docname == "README":
        print("\nAdjusting README content ...")

        # Drop everything before the installation instructions
        marker = "<!-- marker-installation-instructions -->"
        new_start = source[0].find(marker) + len(marker)
        source[0] = "# Installation" + source[0][new_start:]

        # Text Replacements
        # ... to take care of changes in how the link slugs are created by myst
        print("Carrying out text replacements ...")
        source[0] = source[0].replace(
            "#3-configure-and-build", "#configure-and-build"
        )
        source[0] = source[0].replace(
            "../src/utopia/models",
            "https://gitlab.com/utopia-project/utopia/-/tree/master/src/utopia/models",
        )

        return


# -----------------------------------------------------------------------------

def _str2bool(val: str):
    """Copy of strtobool from deprecated distutils package"""
    val = val.lower()
    if val in ("y", "yes", "t", "true", "on", "1"):
        return True
    elif val in ("n", "no", "f", "false", "off", "0"):
        return False
    raise ValueError(f"Invalid truth value {repr(val)}!")


def _find_dirs(base: str, *, exclude_prefixes: list = (".", "_")) -> list:
    return [
        d for d in os.listdir(os.path.join(base))
        if os.path.isdir(os.path.join(base, d)) and
        not any(d.startswith(prefix) for prefix in exclude_prefixes)
    ]


def _copy_figures_flat(
    *, source_dir: str, target_dir: str, file_types: list
) -> list:
    """Copies figures of certain file types from a nested source directory
    into a (flat) target directory.
    Returns a list of (source, target) tuples.
    """
    from pathlib import Path
    from shutil import copy2

    copies = []

    src_files = []
    for file_type in file_types:
        src_files += [str(p) for p in Path(source_dir).rglob(file_type)]

    if not src_files:
        print("There were NO source files to copy!")
        print(
            f"Make sure there was plot output in\n  {source_dir}\nand that "
            f"the file extensions ({file_types}) are specified as expected.\n"
        )
        return

    _files = "\n".join(f"  .{f[len(source_dir):]}" for f in src_files)
    print(f"Files found within source dir ({source_dir}):\n{_files}")

    print(f"\nNow copying into target directory ({target_dir}) as ...")
    for f in src_files:
        print(f"  ./{os.path.basename(f):<42s}", end="")
        target_path = os.path.join(target_dir, os.path.basename(f))

        if os.path.exists(target_path):
            print(" -- overwriting existing ...")
        else:
            os.makedirs(os.path.dirname(target_path), exist_ok=True)
            print("")

        # Now copy
        copy2(f, target_path)
        copies.append((f, target_path))

    print("\nCopying all done.")
    return copies


def generate_figures():
    """Generates plot output from utopia model runs"""
    TOGGLE_ENVVAR = "UTOPIA_DOC_GENERATE_FIGURES"
    ONLY_MODELS_ENVVAR = "UTOPIA_DOC_GENERATE_FIGURES_FOR_MODELS"

    print(
        f"Checking {TOGGLE_ENVVAR} environment variable for whether figures "
        "should be generated ..."
    )
    if (
        not os.environ.get(TOGGLE_ENVVAR) or
        not _str2bool(os.environ.get(TOGGLE_ENVVAR, "False"))
    ):
        print(
            f"Not generating figures. Set the {TOGGLE_ENVVAR} "
            "environment variable to control this behavior.\n\n"
        )
        return

    from utopya import Model

    cfg_base_dir = "@CMAKE_CURRENT_SOURCE_DIR@/_cfg"
    figure_out_dir = "@CMAKE_CURRENT_SOURCE_DIR@/_static/_gen"
    file_types = ("*.png", "*.pdf", "*.mp4")  # should be glob strings
    num_figures = 0

    # Find out which models to generate plots for
    only_models = os.environ.get(ONLY_MODELS_ENVVAR, "all")
    if only_models != "all":
        print(f"Got {ONLY_MODELS_ENVVAR}.")
        only_models = only_models.split(",")
        print(f"Generating only for models:  {', '.join(only_models)}.")
    else:
        print(f"Did not get {ONLY_MODELS_ENVVAR}, generating for all models.")

    # Define models to run this for
    model_names = _find_dirs(cfg_base_dir)
    print(f"Found model configuration(s):  {', '.join(model_names)}\n\n")

    for model_name in model_names:
        if only_models != "all" and model_name not in only_models:
            print(f"Skipping model '{model_name}' ...\n")
            continue

        model = Model(name=model_name, use_tmpdir=True, sim_errors="raise")

        # Determine the names of all config directories in there
        cfg_names = _find_dirs(os.path.join(cfg_base_dir, model_name))
        print(
            "Configurations to generate figures from:\n  ",
            ", ".join(cfg_names),
        )

        # ... and generate output for each of them
        for cfg_name in cfg_names:
            print(f"\n\n\n--- Configuration:  {cfg_name} ... ---")
            cfg_dir = os.path.join(cfg_base_dir, model_name, cfg_name)

            # Run
            mv, _ = model.create_run_load(
                run_cfg_path=os.path.join(cfg_dir, "run.yml")
            )

            # Plot
            mv.pm.raise_exc = True
            mv.pm.plot_from_cfg(
                plots_cfg=os.path.join(cfg_dir, "eval.yml")
            )

            # Gather figure output into
            paths = _copy_figures_flat(
                source_dir=mv.pm.common_out_dir,
                target_dir=os.path.join(figure_out_dir, model_name, cfg_name),
                file_types=file_types,
            )
            num_figures += len(paths)

    print(
        f"Generated {num_figures} figures from {len(model_names)} models.\n\n"
    )



# -----------------------------------------------------------------------------
# -----------------------------------------------------------------------------
# -----------------------------------------------------------------------------


def setup(app):
    print("\n\nNow building sphinx docs ...")
    print(f"  Version:      {version}")
    print(f"  Source dir:   {doc_dir}")
    print(f"  Doxygen dir:  {breathe_projects['utopia']}")
    print("")

    # Perform model simulations to generate to-be-embedded figures
    generate_figures()

    # Handle some events manually
    app.connect("source-read", manipulate_source_read)
    app.connect("missing-reference", on_missing_reference)
